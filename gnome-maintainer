#!/usr/bin/env python
#
# Python script useful to maintainers.
# Copyright (C) 2006-2011 Martyn Russell <martyn@lanedo.com>
#
# This script will:
#  - Summarise bugs mentioned in the ChangeLog (from Bugzilla)
#  - List translation updates
#  - List bugs fixed
#  - Output the summary and translations using a template (in HTML too)
#  - Upload your tarball and install the module.
#  - Create the email for you just to send it.
#
# Usage:
#  - You should run this script from the directory of the project you maintain.
#  - You need to specify a revision to compare the HEAD/TRUNK.
#
# Changes:
#  - If you make _ANY_ changes, please send them in so I can incorporate them.
#
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

import sys
import os
import string
import re
import urllib
import csv
import optparse
import time
import datetime
#import gnomevfs, gobject
import StringIO
import libxml2
from string import Template

# Script
script_name = 'Maintainer'
script_version = '0.10'
script_about = 'A script to do the laborious tasks when releasing a GNOME project.'

# Bugzilla Services used (comment out those unused for you)
bugzillas = {
        'GNOME': {
                'shortcut'  : 'GB',
                'url'       : 'bugzilla.gnome.org',
                'username'  : None,
                'password'  : None,
                'can_query' : True,
                'service'   : None
        },
        'Debian': {
                'shortcut'  : 'DB',
                'url'       : 'bugs.debian.org',
                'username'  : None,
                'password'  : None,
                'can_query' : False,
                'service'   : None
        },
        'RedHat': {
                'shortcut'  : 'RH',
                'url'       : 'bugzilla.redhat.com',
                'username'  : None,
                'password'  : None,
                'can_query' : False,
                'service'   : None
        },
        'FreeDesktop': {
                'shortcut'  : 'FD',
                'url'       : 'bugs.freedesktop.org',
                'username'  : None,
                'password'  : None,
                'can_query' : False,
                'service'   : None
        }
#        'Mozilla': {
#                'shortcut'  : 'MB',
#                'url'       : 'bugzilla.mozilla.org',
#                'username'  : None,
#                'password'  : None,
#                'can_query' : False,
#                'service'   : None
#        },
#        'Nokia': {
#                'shortcut'  : 'NB',
#                'url'       : 'projects.maemo.org/bugzilla',
#                'username'  : None,
#                'password'  : None,
#                'can_query' : False,
#                'service'   : None
#        }
}

# Translation directories
po_dir = 'po'
help_dir = 'help'

# Translator information template
translator_template = 'Updated $lang: $translator'

# Addresses
upload_server = 'master.gnome.org'

# Formatting
format_bullet = '*'
format_date = '%d %B %Y'

# Cached bug IDs to names
bug_names = {}

# Default templates
template = '''
What is it?
===========

$about

Where can I get it?
===================

Download $name $version from:

  $download

  $md5sums

What's new?
===========

The changes are:
$fixed

Translations:
$translations

Manual Translations:
$help_translations

--
$footer
'''

template_in_html = '''
<p>$name $version is now available for download from:</p>
<ul>
  <li><a href="$download">$download</a></li>
</ul>
<p>$md5sums</p>

<h3>What is it?</h3>
<p>$about</p>

<h3>What's New</h3>
$news

<h3>Bugs Fixed</h3>
$fixed

<h3>Translations</h3>
$translations

<h3>Help Manual Translations</h3>
$help_translations

--
$footer
'''

template_update_news = '''
NEW in %s:
==============
%s

Translations:
%s

Help Manual Translations:
%s

'''

def debug(string):
        if opts.debug:
                print string

class BugzillaService:
        def __init__(self, package_info, shortcut, name, url, username, password, can_query):
                self.package_info = package_info
                self.name = name
                self.shortcut = shortcut
                self.url = url
                self.username = username
                self.password = password
                self.can_query = can_query

        def ask(self, bugs, query, url, just_titles):
                debug('Retrieving bug information for: %s...' % (bugs))

                f = urllib.urlopen(query)
                s = f.read()
                f.close()

                try:
                        doc = libxml2.parseDoc(s)
                except:
                        return ''

                root = doc.children
                if root.name != "bugzilla":
                        return 'Response from %s Bugzilla was not good, ' \
                               'We should know better than to interface with public services :)' % (self.name)

                summary = ''

                for bug in doc.xpathEval('//bug'):
                        bug_id = bug.xpathEval('bug_id')[0].content
                        short_desc = bug.xpathEval('short_desc')[0].content
                        bug_status = bug.xpathEval('bug_status')[0].content

                        resolution_node = bug.xpathEval('resolution')
                        if resolution_node:
                                resolution = resolution_node[0].content
                        else:
                                resolution = 'NONE'

                        reporter_name_node = bug.xpathEval('reporter/@name')
                        if reporter_name_node:
                                reporter_name = reporter_name_node[0].content
                        else:
                                reporter_name = 'NONE'

                        assigned_to_node = bug.xpathEval('assigned_to/@name')
                        if assigned_to_node:
                                assigned_to = assigned_to_node[0].content
                        else:
                                assigned_to = 'NONE'

                        if not just_titles:
                                if summary != '':
                                        summary += '  ----------------------------------------\n'
                                else:
                                        summary = ''

                                link = '%s%s' % (url, bug_id)

                                summary += '  %s Bug #%s, %s\n' % (self.name, bug_id, short_desc)
                                summary += '  %s\n' % (link)
                                summary += '  Reporter: %s, Assigned to: %s\n' % (reporter_name, assigned_to)
                                summary += '  Status: %s, Resolution: %s\n' % (bug_status, resolution)
                        else:
                                summary += '  %s Fixes: %s#%s, %s\n' % (format_bullet, self.shortcut, bug_id, short_desc)

                doc.freeDoc()

                return summary

        def generate_request(self, bug_list, just_titles):
                if not bug_list:
                        return ''

                if not self.can_query:
                        debug('Not retrieving bug information for bug list (disabled in config)')
                        summary = ''

                        for bug in bug_list.split(','):
                                summary += '  %s Fixes: %s#%s, \n' % (format_bullet, self.shortcut, bug)

                        return summary

                if self.username and self.password:
                        query = 'https://%s:%s@%s/show_bug.cgi?ctype=xml;id=' % (self.username, self.password, self.url)
                else:
                        query = 'https://%s/show_bug.cgi?ctype=xml;id=' % (self.url)

                bugs = bug_list.split()[0]
                s = bugs
                s = s.replace(',', '%2c')
                s = s.replace(self.shortcut + '#', '')

                query = query + s
                bug_url = 'https://%s/show_bug.cgi?id=' % (self.url)

                debug('Using query "%s"' % (query))

                return self.ask (bugs, query, bug_url, just_titles)

        def get_summary(self, bug_list):
                if len(bug_list) < 1:
                        return ''

                return self.generate_request(bug_list, True)

        def url_to_shortcut(self, string):
                if string.find('bugzilla.gnome.org') > 0:
                        return 'GB#'
                elif string.find('bugs.debian.org') > 0:
                        return 'DB#'
                elif string.find('bugs.freedesktop.org') > 0:
                        return 'FD#'
                elif string.find('bugzilla.redhat.com') > 0:
                        return 'RH#'
                elif string.find('bugs.gentoo.org') > 0:
                        return 'GT#'
                elif string.find('bugzilla.mozilla.org') > 0:
                        return 'MB#'
                elif string.find('projects.maemo.org/bugzilla') > 0:
                        return 'NB#'

                return None

        def shortcut_to_url(self, string):
                if string.find('GB#') > 0:
                        return 'bugzilla.gnome.org'
                elif string.find('DB#') > 0:
                        return 'bugs.debian.org'
                elif string.find('FD#') > 0:
                        return 'bugs.freedesktop.org'
                elif string.find('RH#') > 0:
                        return 'bugzilla.redhat.com'
                elif string.find('GT#') > 0:
                        return 'bugs.gentoo.org'
                elif string.find('MB#') > 0:
                        return 'bugzilla.mozilla.org'
                elif string.find('NB#') > 0:
                        return 'projects.maemo.org/bugzilla'

                return None

class PackageInfo:
        def __init__(self, version):
                self.name = None
                self.version = version
                self.module = None
                self.description = None
                self.vc_command = None
                self.vc_paramters = None

                if os.path.exists('CVS'):
                        debug('Version control system is CVS')
                        self.vc_command = 'cvs'
                        self.vc_parameters = '-u'
                elif os.path.exists('.svn'):
                        debug('Version control system is SVN')
                        self.vc_command = 'svn'
                        self.vc_parameters = ''
                elif os.path.exists('.git'):
                        debug('Version control system is GIT')
                        self.vc_command = 'git'
                        self.vc_parameters = ''
                else:
                        print 'Version control system unrecognised, not cvs or svn'
                        sys.exit(1)

                # Get information from all sources
                self.get_doap_info()
                self.get_configh_info()

                # Make sure we have everything we need, otherwise exit.
                self.sanity_check()

        def sanity_check(self):
                if self.vc_command == None:
                        print 'Could not get version control system'
                        sys.exit(1)
                if self.name == None:
                        print 'Could not get package name'
                        sys.exit(1)
                if self.version == None:
                        print 'Could not get package version'
                        sys.exit(1)
                if self.module == None:
                        print 'Could not get package module'
                        sys.exit(1)

        def get_doap_info(self):
                filename = None

                for file in os.listdir("."):
                        if file.endswith(".doap"):
                                if filename != None:
                                        print 'Multiple .doap files found, no way forward'
                                        return
                                else:
                                        filename = file

                if filename == None:
                        print 'Could not find .doap file in current directory'
                        return

                if not os.path.exists(filename):
                        print 'Could not find %s in current directory' % (filename)
                        return

                f = open(filename, 'r')
                s = f.read()
                f.close()

                key = {}
                key['package'] = '<name'
                key['version'] = '' # Not in DOAP file
                key['bugreport'] = '<bug-database rdf:resource="'
                key['description'] = '<description'

                for line in s.splitlines(1):
                        if line.find(key['package']) > 0:
                                p2 = line.rfind('</name>')
                                p1 = line.find('>') + 1
                                st = line[p1:p2]
                                if len(st) > 0:
                                        self.name = st
                                        debug('Using "%s" as name from %s' % (st, filename))
                        elif line.find(key['bugreport']) > 0:
                                p2 = line.rfind('"')
                                p1 = line.rfind('=') + 1
                                st = line[p1:p2]
                                if len(st) > 0:
                                        self.module = st
                                        debug('Using "%s" as module from %s' % (st, filename))
                        elif line.find(key['description']) > 0:
                                p2 = line.rfind('</description>')
                                p1 = line.find('>') + 1
                                st = line[p1:p2]
                                if len(st) > 0:
                                        self.description = st
                                        debug('Using "%s" as description from %s' % (st, filename))

        def get_configh_info(self):
                filename = 'config.h'

                if not os.path.exists(filename):
                        if not opts.package_version:
                                print 'Expected %s to exist, but it could not be found in current directory' % (filename)
                        return

                f = open(filename, 'r')
                s = f.read()
                f.close()

                key = {}
                key['package'] = '#define PACKAGE_NAME "'
                key['version'] = '#define PACKAGE_VERSION "'
                key['bugreport'] = '#define PACKAGE_BUGREPORT "'

                for line in s.splitlines(1):
                        if line.startswith(key['package']):
                                p1 = len(key['package'])
                                p2 = line.rfind('"')
                                st = line[p1:p2]
                                if len(st) > 0:
                                        self.name = st
                                        debug('Using "%s" as name %s' % (st, filename))
                        elif line.startswith(key['version']):
                                p1 = len(key['version'])
                                p2 = line.rfind('"')
                                st = line[p1:p2]
                                if len(st) > 0:
                                        self.version = st
                                        debug('Using "%s" as version %s' % (st, filename))
                        elif line.startswith(key['bugreport']):
                                p2 = line.rfind('"')
                                p1 = line.rfind('=') + 1
                                st = line[p1:p2]
                                if len(st) > 0:
                                        self.module = st
                                        debug('Using "%s" as module %s' % (st, filename))

        def get_svn_root(self):
                info = os.popen('svn info --xml').read()

                key = '<root>'
                start = info.find(key)
                if start == -1:
                        print 'Could not get Root (start) for subversion details'
                        sys.exit(1)

                start += len(key)
                key = '</root>'
                end = info.find(key, start)
                if end == -1:
                        print 'Could not get Root (end) for subversion details'
                        sys.exit(1)

                return info[start:end]

        def get_svn_url(self):
                info = os.popen('svn info --xml').read()

                key = '<url>'
                start = info.find(key)
                if start == -1:
                        print 'Could not get URL (start) for subversion details'
                        sys.exit(1)

                start += len(key)
                key = '</url>'
                end = info.find(key, start)
                if end == -1:
                        print 'Could not get URL (end) for subversion details'
                        sys.exit(1)

                return info[start:end]

def get_bugs(service, tag):
        who_exp = ''

        # Commands to get change set
        if pi.vc_command == 'cvs':
                cmd = '%s diff %s -r %s ChangeLog' % (pi.vc_command, pi.vc_parameters, tag)
        elif pi.vc_command == 'svn':
                url = get_svn_url()
                root = get_svn_root()
                revision = "%s/tags/%s" % (root, tag)
                debug('Using SVN root: %s...' % (root))
                debug('Using SVN diff url1: %s...' % (url))
                debug('Using SVN diff url2: %s...' % (revision))
                cmd = '%s diff %s %s/ChangeLog %s/ChangeLog' % (pi.vc_command, pi.vc_parameters, revision, url)
        elif pi.vc_command == 'git':
                cmd = '%s %s log %s..HEAD' % (pi.vc_command, pi.vc_parameters, tag)

        # Regular expressions need to get details
        if pi.vc_command == 'cvs' or pi.vc_command == 'svn':
                who_exp = '^\+(?P<date>[0-9][0-9][0-9][0-9]\-[0-9][0-9]\-[0-9][0-9]) ' \
                          '(?P<name>.*) <*@*>*'
                bug_exp = '.*#(?P<bug>[0-9]+)(.*\((?P<name>.*)\))?'
        elif pi.vc_command == 'git':
                who_exp = '^Author: (?P<name>.*) <*@*>*'
                bug_exp = '.*(?P<repo>((bug |GB#|DB#|NB#|FD#|RH#|GT#|MB#)|(http(s)?[:][/][/].*?(id|bug)[=])))(?P<bug>[0-9]+)(.*\((?P<name>.*)\))?'

        bugs = ''

        # Pattern to match ChangeLog entry
        changelog_pattern = re.compile(who_exp, re.S | re.M)

        # Pattern to match bug fixers name, e.g.: "#123456 (Martyn Russell)"
        bugfix_pattern = re.compile(bug_exp, re.S | re.M | re.I)

        pos = 0
        changes = os.popen(cmd).read()

        while not pos == -1:
                start = pos

                # Find end of first line
                end = changes.find('\n', pos)
                line = changes[pos:end]

                pos = end + 1

                # Try and get the second line
                end = changes.find('\n', pos)
                if not end == -1:
                        line = changes[start:end]

                if len(line) < 1:
                        break

                # Check this is a change
                if not pi.vc_command == 'git' and not line[0] == '+':
                        continue

                # Get committer details
                match = changelog_pattern.match(line)
                if match:
                        last_committer = match.group('name')
                        continue

                # Get bug fix details
                match = bugfix_pattern.match(line)
                if not match:
                        continue

                bug = match.group('bug')
                name = match.group('name')
                repo = match.group('repo')

                if len(repo) > 3:
                        repo_shortcut = service.url_to_shortcut(repo)
                else:
                        repo_shortcut = repo

                if repo_shortcut == None:
                        debug('Repository was unrecognised from URL %s' % (repo))
                        continue

                # Don't include the end '#' in repo in comparison
                if service.shortcut != None and service.shortcut != repo_shortcut[:-1]:
                        continue

                if bug == '':
                        continue

                if name == None:
                        name = last_committer.strip()
                else:
                        name = name.replace('\n', '')
                        name = name.replace('\t', '')
                        name = name.replace('+', ' ')
                        name = name.strip()

                repo_lower = repo.lower()
                if repo_lower == 'bug ':
                        repo = 'GB#'
                else:
                        repo = repo.upper()

                # Set name for bug
                bug_names[bug] = name

                if bugs.find(bug) > -1:
                        continue

                # Add bug to list
                if not bugs == '':
                        bugs = bugs + ','

                bugs += bug

        return bugs

def get_last_translator(lang, dir):
        exp = '["]Last[-]Translator[:] (?P<name>.*?)( *[<].*[>]*)?\n'
        trans_pattern = re.compile(exp)

        file = os.path.join (dir, lang + ".po")
        debug('  Trying to open PO file "%s"....' % (file))

        try:
                f = open(file, 'r')
        except IOError, (errno, strerror):
                # If this fails, we try to use the 'dir/lang/lang.po' for help PO files
                file = os.path.join (dir, lang, lang + ".po")
                debug('Trying to open PO file "%s"....' % (file))

                try:
                        f = open(file, 'r')
                except IOError, (errno, strerror):
                        return ''

        translator = ''

        line = f.readline()

        while translator == '' and line != '':
                match = trans_pattern.match (line)
                if not match:
                        line = f.readline()
                        continue

                translator = match.group ('name')

        if translator != '':
                translator = translator.strip()

        f.close()

        return translator

def get_translators(pi, type, tag, dir):
        translators = {}

        if not os.path.exists(dir):
                return None

        if pi.vc_command == 'cvs':
                cmd = '%s diff -u -r %s %s/ChangeLog' % (pi.vc_command, tag, dir)

                # Set changelog format for getting name
                who_exp = '^\+(?P<date>[0-9][0-9][0-9][0-9]\-[0-9][0-9]\-[0-9][0-9]) ' \
                          '(?P<name>.*) <*@*>*'
                lang_exp = '.*\* (.*/)?(?P<lang>.*).po: ((.*) by (?P<name>[^.]*)\.?)?'

                # Pattern to match ChangeLog entry
                changelog_pattern = re.compile(who_exp, re.S | re.M)

                # Pattern to match language and sponsored name for change, e.g.: 
                # "en_GB.po: Updated by Martyn Russell"
                lang_pattern = re.compile(lang_exp, re.S | re.M)
        elif pi.vc_command == 'svn':
                url = pi.get_svn_url()
                root = pi.get_svn_root()

                revision = "%s/tags/%s" % (root, tag)
                debug('Using SVN root: %s...' % (root))
                debug('Using SVN diff url1: %s...' % (url))
                debug('Using SVN diff url2: %s...' % (revision))

                cmd = '%s diff %s %s/%s/ChangeLog %s/%s/ChangeLog' % (pi.vc_command, pi.vc_parameters, revision, dir, url, dir)

                # Set changelog format for getting name
                who_exp = '^\+(?P<date>[0-9][0-9][0-9][0-9]\-[0-9][0-9]\-[0-9][0-9]) ' \
                          '(?P<name>.*) <*@*>*'
                lang_exp = '.*\* (.*/)?(?P<lang>.*).po: ((.*) by (?P<name>[^.]*)\.?)?'

                # Pattern to match ChangeLog entry
                changelog_pattern = re.compile(who_exp, re.S | re.M)

                # Pattern to match language and sponsored name for change, e.g.: 
                # "en_GB.po: Updated by Martyn Russell"
                lang_pattern = re.compile(lang_exp, re.S | re.M)

        if not pi.vc_command == 'git':
                pos = 0
                changes = os.popen(cmd).read()

                while not pos == -1:
                        start = pos

                        # Find end of first line
                        end = changes.find('\n', pos)
                        line = changes[pos:end]

                        pos = end + 1

                        # Try and get the second line
                        end = changes.find('\n', pos)
                        if not end == -1:
                                line = changes[start:end]

                        if len(line) < 1:
                                break

                        # Check this is a change
                        if not line[0] == '+':
                                continue

                        # Get committer details
                        match = changelog_pattern.match(line)
                        if match:
                                last_committer = match.group('name')
                                #date = match.group('date')
                                continue

                        # Get bug fix details
                        match = lang_pattern.match(line)
                        if not match:
                                continue

                        lang = match.group('lang')
                        name = match.group('name')

                        if lang == '':
                                continue

                        # Get last translator from .po file
                        last_translator = get_last_translator (lang, dir)

                        debug('Found lang "%s" with last translator "%s"' % (lang, last_translator))

                        if last_translator != '':
                                if translators.has_key (lang):
                                        if translators[lang].find (last_translator) == -1:
                                                translators[lang] += ', ' + last_translator
                                        else:
                                                translators[lang] = last_translator

                        if name == None:
                                name = last_committer.strip()

                                #if opts.debug:
                                #        print 'Found lang "%s" with last committer "%s" on "%s"' % (lang, name, date) 
                        else:
                                name = name.replace('\n', '')
                                name = name.replace('\t', '')
                                name = name.replace('+', ' ')
                                name = name.strip()

                        debug('Found lang "%s" with last committer "%s" **' % (lang, name))

                        if last_translator != '':
                                if translators.has_key (lang):
                                        if translators[lang].find (last_translator) == -1:
                                                translators[lang] += ', ' + last_translator
                                        else:
                                                translators[lang] = last_translator

                        if translators.has_key(lang):
                                if translators[lang].find(name) > -1:
                                        continue;

                                translators[lang] += ', ' + name
                        else:
                                translators[lang] = name
        else:
                cmd = 'git diff-tree --name-only -r %s.. %s/*.po' % (tag, dir)
                text = os.popen(cmd).read()

                file_exp = '^%s/(?P<lang>.*).po' % (dir)
                file_pattern = re.compile(file_exp, re.S | re.M)

                for line in text.splitlines():
                        match = file_pattern.match(line)
                        if not match:
                                continue

                        lang = match.group('lang')

                        if lang == '':
                                continue

                        debug('Found lang %s' % (lang))

                        cmd = 'git log --pretty=format:"%%an" %s.. -- %s/%s.po' % (tag, dir, lang)
                        who = os.popen(cmd).read()

                        names = who.split('\n')
                        for name in names:
                                debug('  Found "%s"' % (name))

                                if len(name) < 1:
                                        continue

                                if translators.has_key(lang):
                                        if translators[lang].find(name) > -1:
                                                continue

                                        translators[lang] += ', ' + name
                                else:
                                        translators[lang] = name

                        # Get last translator from .po file
                        last_translator = get_last_translator (lang, dir)

                        debug('  Last translator "%s"' % (last_translator))

                        if len(last_translator) < 1:
                                continue

                        if translators.has_key(lang):
                                if translators[lang].find(last_translator) > -1:
                                        continue

                                translators[lang] += ', ' + last_translator
                        else:
                                translators[lang] = last_translator

        summary = ''

        if opts.html:
                summary += '<ul>'

        sorted_langs = translators.keys ()
        sorted_langs.sort ()

        for lang in sorted_langs:
                if len(summary) > 0:
                        summary += '\n'

                t = Template(translator_template)
                text = t.substitute (translator = translators[lang], lang = lang)
                if opts.html:
                        summary += '<li>%s</li>' % (text)
                else:
                        summary += '  %s %s' % (format_bullet, text)

        if opts.html:
                summary += '\n</ul>'

        if len(summary) < 1:
                return None

        return summary

def get_description(pi):
        debug('Retrieving product descripton for %s ...' % (pi.name))

        if pi.description != None:
                return pi.description

        query = 'https://bugzilla.gnome.org/browse.cgi?product=%s' % (pi.name)
        f = urllib.urlopen(query)
        s = f.read()
        f.close()

        if len(s) < 1:
                return ''

        #
        # HACK ALERT! HACK ALERT!
        #
        # This is likely to change if the Bugzilla page formatting changes, so
        # we put a lot of debugging in here.

        s1 = '<p><i>'
        i = s.find(s1)
        if i == -1:
                debug('Could not find string "%s"' % (s1))
                return ''

        start = i + len(s1)

        s2 = '</i></p>'
        end = s.find(s2, i + 1)
        if end == -1:
                debug('Could not find string "%s"' % (s2))
                return ''

        # Set description
        pi.desciption = s[start:end]

        return pi.desciption

def get_default_template():
        if opts.html:
                return template_in_html

        return template

def get_news():
        f = open ('NEWS', 'r')
        s = f.read()
        f.close()
        start = s.find ('NEW in '+ pi.version)
        start = s.find ('\n', start) + 1
        start = s.find ('\n', start) + 1
        end = s.find ('NEW in', start) - 1
        return s[start:end]

def create_release_note(service, tag, template_file):
        # Open template file
        if template_file == '' or template_file == 'DEFAULT':
                debug('Using DEFAULT template')
                s = get_default_template()
        else:
                debug('Using template file "%s"' % (template_file))
                f = open(template_file, 'r')
                s = f.read()
                f.close()

        if len(s) < 1:
                print 'Template file was empty or does not exist'
                sys.exit(1)

        # Check we have everything
        if s.find('$download') == -1:
                print 'Could not find "$download" in template'
                sys.exit(1)

        #if s.find('$news') == -1:
        #        print 'Could not find "$news" in template'
        #        sys.exit(1)

        if s.find('$fixed') == -1:
                print 'Could not find "$fixed" in template'
                sys.exit(1)

        if s.find('$translations') == -1:
                print 'Could not find "$translations" in template'
                sys.exit(1)

        if s.find('$help_translations') == -1:
                print 'Could not find "$help_translations" in template'
                sys.exit(1)

        # Get date for footer
        today = datetime.date.today()
        date = today.strftime(format_date)

        # Set up variables
        name = pi.name       # Needed for template
        version = pi.version # Needed for template

        # FIXME: Get ALL bugs,
        bugs_gb = get_bugs(service, tag)
        bugs_nb = ''

        download = 'http://download.gnome.org/sources/%s/%s/' % (pi.name.lower(), 
                                                                 pi.version)

        # Get an MD5 sum of the tarballs.
        md5sums = ''
        tarball = '%s-%s.tar.gz' % (pi.name.lower(), pi.version)

        if not os.path.exists(tarball):
                print 'Tarball does not exist, could not find %s' % (tarball)
                sys.exit(1)

        cmd = 'md5sum %s' % (tarball)
        md5sums += os.popen(cmd).read()

        #cmd = 'md5sum %s-%s.tar.bz2' % (pi.name.lower(), pi.version)
        #md5sums += os.popen(cmd).read()

        if opts.html:
                md5sums = md5sums.replace('\n', '<br>\n')

        about = get_description(pi)

        #news = get_news()

        # FIXME: Get ALL bugs,
        fixed = service.get_summary(bugs_gb)
        translations = get_translators(pi, "source code", tag, po_dir)
        if translations == None:
                translations = ''

        help_translations = get_translators(pi, "help manual", tag, help_dir)
        if help_translations == None:
                help_translations = ''

        footer = '%s\n%s team' % (date, pi.name)

        if opts.html:
                footer = footer.replace('\n', '<br>\n')
                footer = '<p>%s</p>' % footer

        # Substitute variables
        t = Template(s)
        text = t.substitute(locals())

        return text

def create_release_email(to, tag, template_file):
        release_note = create_release_note(tag, template_file)

        t = Template(release_note)
        text = t.substitute(locals())

        body = ''

        for line in text.splitlines():
                body = body + line + '%0d'

        # Get package name and version
        get_package_info()

        subject = 'ANNOUNCE: %s %s released' % (pi.name, pi.version)
        url = 'mailto:%s?subject=%s&body=%s' % (to, subject, body)

        return url;

def upload_tarball(pi):
        # This is the tarball we are going to upload
        username = opts.upload
        tarball = '%s-%s.tar.gz' % (pi.name.lower(), pi.version)

        print 'Attempting to upload tarball: %s to master.gnome.org...' % (tarball)

        cmd = 'scp %s %s@%s:' % (tarball, username, upload_server)
        fp = os.popen(cmd)
        retval = fp.read()
        status = fp.close()

        if status and (not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0):
                print 'Unable to upload your tarball'
        else:
                print 'Sucessfully uploaded tarball'

        print 'Attempting to install-module using tarball: %s...' % (tarball)

        cmd = 'ssh %s@%s install-module -u %s' % (username, upload_server, tarball)
        success = os.popen(cmd).read()

        # Make sure we check the return value
        fp = os.popen(cmd)
        retval = fp.read()
        status = fp.close()

        if status and (not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0):
                print 'Unable to install module'
        else:
                print 'Sucessfully installed module'


def update_news(bugzillas, pi, revision):
        summary = ''

        for name in bugzillas:
                service = bugzillas[name]['service']
                bugs = get_bugs(service, revision)

                if len(bugs) < 1:
                        continue

                summary += service.get_summary(bugs)

        po_translators = get_translators(pi, "source code", revision, po_dir)
        help_translators = get_translators(pi, "help manual", revision, help_dir)
        output = template_update_news % (pi.version, summary, po_translators, help_translators)

        f = open('NEWS', 'r')
        s = f.read()
        f.close()

        output += s;

        f = open('NEWS', 'w')
        f.write(output)
        f.close()

def tag_svn():
        new_version = opts.tag[opts.tag.find ('_')+1:].replace ('_', '.')
        url1 = pi.get_svn_url()
        url2 = pi.get_svn_root() + '/tags/' + opts.tag

        cmd = 'svn copy %s %s -m "Tagged for release %s."' % (url1, url2, new_version)

        debug('Tagging using command: ' + cmd)
        success = os.popen(cmd).read()

        # Make sure we check the return value
        fp = os.popen('{ %s; } 2>&1' % cmd, 'r')
        retval = fp.read()
        status = fp.close()

        if status and (not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0):
                print 'Unable to tag SVN'
        else:
                print 'Sucessfully tagged SVN'

#
# Output helper functions
#
def output_summary(bugzillas, revision):
        summary = ''

        for name in bugzillas:
                service = bugzillas[name]['service']
                bugs = get_bugs(service, revision)

                if len(bugs) < 1:
                        continue

                summary += '%s summary:\n' % (name)
                summary += service.generate_request(bugs, False)

        if len(summary) < 1:
                print 'No bugs found fixed'
        else:
                print summary

def output_bugs(bugzillas, revision):
        summary = ''

        for name in bugzillas:
                service = bugzillas[name]['service']
                bugs = get_bugs(service, revision)

                if len(bugs) < 1:
                        continue

                summary += '%s bugs:\n' % (name)
                summary += '  %s\n' % (bugs.replace (service.shortcut + '#', ''))

        if len(summary) < 1:
                print 'No bugs found fixed'
        else:
                print summary

def output_bugs_and_titles(bugzillas, revision):
        summary = ''

        for name in bugzillas:
                service = bugzillas[name]['service']
                bugs = get_bugs(service, revision)

                if len(bugs) < 1:
                        continue

                summary += '%s bugs:\n' % (name)
                summary += service.generate_request(bugs, True)

        if len(summary) < 1:
                print 'No bugs found fixed'
        else:
                print summary

#
# Start
#
usage = "usage: %s -r <revision or tag> [options]\n" \
        "       %s --help" % (sys.argv[0], sys.argv[0])

popt = optparse.OptionParser(usage)
popt.add_option('-V', '--version',
                action = 'count',
                dest = 'version',
                help = 'show version information')
popt.add_option('-d', '--debug',
                action = 'count',
                dest = 'debug',
                help = 'show additional debugging')
popt.add_option('-l', '--html',
                action = 'count',
                dest = 'html',
                help = 'write output in HTML')
popt.add_option('-c', '--confirm',
                action = 'count',
                dest = 'confirm',
                help = 'this is required for some actions as confirmation')
popt.add_option('-y', '--get-bugs-only',
                action = 'count',
                dest = 'get_bugs',
                help = 'get a list of bugs fixed')
popt.add_option('-b', '--get-bugs-and-titles',
                action = 'count',
                dest = 'get_bugs_and_titles',
                help = 'get a list of bugs fixed (showing their titles)')
popt.add_option('-s', '--get-summary',
                action = 'count',
                dest = 'get_summary',
                help = 'get summary of bugs from Bugzilla')
popt.add_option('-t', '--get-translators',
                action = 'count',
                dest = 'get_translators',
                help = 'get translation updates')
popt.add_option('-o', '--get-manual-translators',
                action = 'count',
                dest = 'get_manual_translators',
                help = 'get manual translation updates')
popt.add_option('-e', '--get-description',
                action = 'count',
                dest = 'get_description',
                help = 'get the description in bugzilla for this product')
popt.add_option('-w', '--update-news',
                action = 'count',
                dest = 'update_news',
                help = 'update the news with the bugs fixed and translations')
popt.add_option('-a', '--create-release-note',
                action = 'count',
                dest = 'create_release_note',
                help = 'create a release note (can be used with -n)')
popt.add_option('-n', '--release-note-template',
                action = 'store',
                dest = 'release_note_template',
                help = 'file to use for release note template or "DEFAULT"')
popt.add_option('-m', '--create-release-email',
                action = 'store',
                dest = 'create_release_email',
                help = 'who to address the mail to (can be used with -n)')
popt.add_option('-u', '--upload',
                action = 'store',
                dest = 'upload',
                help = 'user name to use when uploading tarball to master.gnome.org')
popt.add_option('-g', '--tag',
                action = 'store',
                dest = 'tag',
                help = 'Tag to add in SVN')
popt.add_option('-r', '--revision',
                action = 'store',
                dest = 'revision',
                help = 'revision or tag to use with -s, -t and -o')
popt.add_option('-v', '--package-version',
                action = 'store',
                dest = 'package_version',
                help = 'version of this package, for use when config.h is not available')

errors = False
need_tag = False

(opts, args) = popt.parse_args()

if opts.version:
        print '%s %s\n%s\n' % (script_name, script_version, script_about)
        sys.exit()

if not opts.get_bugs and not opts.get_bugs_and_titles and not opts.get_summary and \
   not opts.get_translators and not opts.get_manual_translators and \
   not opts.release_note_template and not opts.create_release_note and \
   not opts.create_release_email and not opts.upload and \
   not opts.get_description and \
   not opts.update_news and not opts.tag:
        print 'No option specified'
        print usage
        sys.exit()

if opts.get_bugs or opts.get_bugs_and_titles or opts.get_summary or \
   opts.get_translators or opts.get_manual_translators or \
   opts.create_release_note or opts.create_release_email or \
   opts.update_news:
        need_tag = True

if need_tag and not opts.revision:
        print 'No tag specified'
        print usage
        sys.exit()

if opts.upload and not opts.confirm:
        print 'Uploading WILL *INSTALL* your tarball with install-module!!'
        print 'Are you sure you want to continue?'
        print
        print 'To continue, you must supply the --confirm option'
        sys.exit()

if opts.tag and not opts.confirm:
        print 'This will create a new tag on your SVN repository!!'
        print 'Are you sure you want to continue?'
        print
        print 'To continue, you must supply the --confirm option'
        sys.exit()

if opts.tag and not opts.confirm:
        print 'This will create a new tag on your SVN repository!!'
        print 'Are you sure you want to continue?'
        print
        print 'To continue, you must supply the --confirm option'
        sys.exit()

# PackageInfo needed for:
#
# get_bugs(), get_translators(), get_description(),
# create_release_note(), create_release_email(), upload_tarball(),
# update_news(), tag_svn()
#
pi = PackageInfo(opts.package_version)

# BugzillaService needed for:
#
# output_bugs(), output_bugs_and_titles(), get_summary(),
# create_release_note()
for name in bugzillas:
        service = BugzillaService(pi,
                                  bugzillas[name]['shortcut'],
                                  name,
                                  bugzillas[name]['url'],
                                  bugzillas[name]['username'],
                                  bugzillas[name]['password'],
                                  bugzillas[name]['can_query'])
        bugzillas[name]['service'] = service
        debug('Adding bugzilla service "%s"' % (name))

if opts.get_bugs:
        output_bugs(bugzillas, opts.revision)

if opts.get_bugs_and_titles:
        output_bugs_and_titles(bugzillas, opts.revision)

if opts.get_summary:
        output_summary(bugzillas, opts.revision)

if opts.get_translators:
        translators = get_translators(pi, "source code", opts.revision, po_dir)
        if translators == None:
                print 'No source code translation updates found'
                sys.exit(0)

        debug('\nSouce code translators:')
        print translators

if opts.get_manual_translators:
        translators = get_translators(pi, "help manual", opts.revision, help_dir)
        if translators == None:
                print 'No help manual translation updates found'
                sys.exit(0)

        debug('\nHelp manual translators:')
        print translators

if opts.get_description:
        description = get_description(pi)
        if len(description) < 1:
                print 'No description was found in Doap file or Bugzilla'
                sys.exit(0)

        debug('\nDescription:')
        print description

if opts.create_release_note:
        if opts.release_note_template:
                release_note = create_release_note(pi,
                                                   opts.revision,
                                                   opts.release_note_template)
        else:
                release_note = create_release_note(pi,
                                                   opts.revision,
                                                   'DEFAULT')

        debug('\nRelease Note:')
        print release_note

if opts.create_release_email:
        if opts.release_note_template:
                url = create_release_email(pi,
                                           opts.create_release_email,
                                           opts.revision,
                                           opts.release_note_template)
        else:
                url = create_release_email(pi,
                                           opts.create_release_email,
                                           opts.revision,
                                           'DEFAULT')

        debug('\nCreating email...')
        gnomevfs.url_show(url)

if opts.upload:
        upload_tarball(pi)

if opts.update_news:
        debug('\nUpdating News:')
        update_news(bugzillas, pi, opts.revision)
        debug('\nUpdated!')

if opts.tag:
        if pi.vc_command != "svn":
                print 'Version control system must be SVN'
                sys.exit(1)

        tag_svn()
